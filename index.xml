<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wkz</title><link>https://wkz.github.io/</link><description>Recent content on wkz</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 24 Sep 2022 01:45:00 +0200</lastBuildDate><atom:link href="https://wkz.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>/dev/kmem + GDB Stub = kmemd</title><link>https://wkz.github.io/post/kmemd/</link><pubDate>Sat, 24 Sep 2022 01:45:00 +0200</pubDate><guid>https://wkz.github.io/post/kmemd/</guid><description>This is an introduction to kmemd - a tool for exploring a live Linux kernel&amp;rsquo;s memory in a non-intrusive way using GDB.
When debugging issues in the Linux kernel, I often find myself wanting to inspect the state of internal data structures. This typically involves non-trivial operations like walking liked lists and extracting enclosing objects using the equivalent of container_of etc. Fortunately the kernel comes with a heap of Linux kernel specific Python extensions to GDB, that you can easily extend to make whatever tools you need - things like custom pretty printers for example.</description></item><item><title>Marvell LinkStreet LAG Issues</title><link>https://wkz.github.io/post/mvls-lag/</link><pubDate>Tue, 17 May 2022 15:15:48 +0200</pubDate><guid>https://wkz.github.io/post/mvls-lag/</guid><description>While running some kselftest-like tests on a system made up of three Marvell LinkStreet chips, I uncovered a series of issues related to offloaded link aggregates (LAGs) that are spread across multiple chips.
The system has the following layout:
.--0-1-2-3-4--. .-----a sw1 | .-0-1-4-. &amp;#39;--5-6-7-8-9--&amp;#39; sw0: 6353 (Agate) CPU +---6 sw0 | sw1: 6097 (Opal+) &amp;#39;-2-3-5-&amp;#39; .--0-1-2-3-4--. sw2: 6097 (Opal+) &amp;#39;-----a sw2 | &amp;#39;--5-6-7-8-9--&amp;#39; Software-wise, the system is running NetBox with 5.</description></item></channel></rss>